"use strict";(self.webpackChunkfacerecognitionbrain=self.webpackChunkfacerecognitionbrain||[]).push([[6291],{6291:(t,i,n)=>{n.d(i,{PolygonMaskInstance:()=>r});var e=n(4409);const o="".concat(e.dI," No polygon data loaded."),a="".concat(e.dI," No polygon found, you need to specify SVG url in config."),s=0,l=0,h=.5;class r{constructor(t,i){this._checkInsidePolygon=t=>{var i,n;const o=this._container,s=o.actualOptions.polygon;if(null===s||void 0===s||!s.enable||"none"===s.type||"inline"===s.type)return!0;if(!this.raw)throw new Error(a);const l=o.canvas.size,h=null!==(i=null===t||void 0===t?void 0:t.x)&&void 0!==i?i:(0,e.G0)()*l.width,r=null!==(n=null===t||void 0===t?void 0:t.y)&&void 0!==n?n:(0,e.G0)()*l.height;let c=!1;for(let e=0,a=this.raw.length-1;e<this.raw.length;a=e++){const t=this.raw[e],i=this.raw[a];t.y>r!==i.y>r&&h<(i.x-t.x)*(r-t.y)/(i.y-t.y)+t.x&&(c=!c)}return"inside"===s.type?c:"outside"===s.type&&!c},this._createPath2D=()=>{var t;if(this._container.actualOptions.polygon&&null!==(t=this.paths)&&void 0!==t&&t.length)for(const e of this.paths){var i,n;const t=null===(i=e.element)||void 0===i?void 0:i.getAttribute("d");if(t){const i=new Path2D(t),n=document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGMatrix(),o=new Path2D,a=n.scale(this._scale);o.addPath?(o.addPath(i,a),e.path2d=o):delete e.path2d}else delete e.path2d;if(null!==(n=e.path2d)&&void 0!==n?n:!this.raw)continue;e.path2d=new Path2D;const o=0,a=this.raw[o];e.path2d.moveTo(a.x,a.y),this.raw.forEach(((t,i)=>{var n;i>o&&(null===(n=e.path2d)||void 0===n||n.lineTo(t.x,t.y))})),e.path2d.closePath()}},this._downloadSvgPath=async(t,i)=>{const n=this._container.actualOptions.polygon;if(!n)return;const o=null!==t&&void 0!==t?t:n.url,a=null!==i&&void 0!==i&&i;if(!o||void 0!==this.paths&&!a)return this.raw;const s=await fetch(o);if(!s.ok)throw new Error("".concat(e.dI," occurred during polygon mask download"));return await this._parseSvgPath(await s.text(),i)},this._drawPoints=()=>{if(this.raw)for(const t of this.raw)this._container.particles.addParticle({x:t.x,y:t.y})},this._getEquidistantPointByIndex=t=>{var i,n,e,a,h,r,c,d,u,g;const p=this._container.actualOptions;if(!p.polygon)return;if(null===(i=this.raw)||void 0===i||!i.length||null===(n=this.paths)||void 0===n||!n.length)throw new Error(o);let w,y=0;const v=this.paths.reduce(((t,i)=>t+i.length),0)/p.particles.number.value;for(const o of this.paths){const i=v*t-y;if(i<=o.length){w=o.element.getPointAtLength(i);break}y+=o.length}const f=this._scale;return{x:(null!==(e=null===(a=w)||void 0===a?void 0:a.x)&&void 0!==e?e:s)*f+(null!==(h=null===(r=this.offset)||void 0===r?void 0:r.x)&&void 0!==h?h:s),y:(null!==(c=null===(d=w)||void 0===d?void 0:d.y)&&void 0!==c?c:l)*f+(null!==(u=null===(g=this.offset)||void 0===g?void 0:g.y)&&void 0!==u?u:l)}},this._getPointByIndex=t=>{var i;if(null===(i=this.raw)||void 0===i||!i.length)throw new Error(o);const n=this.raw[t%this.raw.length];return{x:n.x,y:n.y}},this._getRandomPoint=()=>{var t;if(null===(t=this.raw)||void 0===t||!t.length)throw new Error(o);const i=(0,e.Vh)(this.raw);return{x:i.x,y:i.y}},this._getRandomPointByLength=()=>{var t,i,n,a,h,r;if(!this._container.actualOptions.polygon)return;if(null===(t=this.raw)||void 0===t||!t.length||null===(i=this.paths)||void 0===i||!i.length)throw new Error(o);const c=(0,e.Vh)(this.paths),d=Math.floor((0,e.G0)()*c.length)+1,u=c.element.getPointAtLength(d),g=this._scale;return{x:u.x*g+(null!==(n=null===(a=this.offset)||void 0===a?void 0:a.x)&&void 0!==n?n:s),y:u.y*g+(null!==(h=null===(r=this.offset)||void 0===r?void 0:r.y)&&void 0!==h?h:l)}},this._initRawData=async t=>{const i=this._container.actualOptions.polygon;if(i){if(i.url)this.raw=await this._downloadSvgPath(i.url,t);else if(i.data){const n=i.data;let o;if((0,e.Kg)(n))o=n;else{const t=t=>'<path d="'.concat(t,'" />'),i=(0,e.cy)(n.path)?n.path.map(t).join(""):t(n.path);o="<svg ".concat('xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"',' width="').concat(n.size.width,'" height="').concat(n.size.height,'">').concat(i,"</svg>")}this.raw=await this._parseSvgPath(o,t)}this._createPath2D(),this._engine.dispatchEvent("polygonMaskLoaded",{container:this._container})}},this._parseSvgPath=async(t,i)=>{var o,a,s;const l=null!==i&&void 0!==i&&i;if(void 0!==this.paths&&!l)return this.raw;const r=this._container,c=r.actualOptions.polygon;if(!c)return;const d=(new DOMParser).parseFromString(t,"image/svg+xml"),u=d.getElementsByTagName("svg")[0];let g=u.getElementsByTagName("path");g.length||(g=d.getElementsByTagName("path")),this.paths=[];for(let n=0;n<g.length;n++){const t=g.item(n);t&&this.paths.push({element:t,length:t.getTotalLength()})}const p=this._scale;this.dimension.width=parseFloat(null!==(o=u.getAttribute("width"))&&void 0!==o?o:"0")*p,this.dimension.height=parseFloat(null!==(a=u.getAttribute("height"))&&void 0!==a?a:"0")*p;const w=null!==(s=c.position)&&void 0!==s?s:{x:50,y:50},y=r.canvas.size;this.offset={x:y.width*w.x/e.a5-this.dimension.width*h,y:y.height*w.y/e.a5-this.dimension.height*h};const{parsePaths:v}=await n.e(7299).then(n.bind(n,7299));return v(this.paths,p,this.offset)},this._polygonBounce=async(t,i,o)=>{const a=this._container.actualOptions.polygon;if(!this.raw||null===a||void 0===a||!a.enable||"top"!==o)return!1;if("inside"===a.type||"outside"===a.type){let i,o,a;const s=t.getPosition(),l=t.getRadius(),h=1;for(let r=0,c=this.raw.length-h;r<this.raw.length;c=r++){const h=this.raw[r],d=this.raw[c],{calcClosestPointOnSegment:u}=await n.e(7299).then(n.bind(n,7299));i=u(h,d,s);const g=(0,e.vr)(s,i);if([o,a]=[g.dx,g.dy],g.distance<l){const{segmentBounce:i}=await n.e(7299).then(n.bind(n,7299));return i(h,d,t.velocity),!0}}if(i&&void 0!==o&&void 0!==a&&!this._checkInsidePolygon(s)){const n={x:1,y:1},e=2*l,o=-1;return s.x>=i.x&&(n.x=-1),s.y>=i.y&&(n.y=-1),t.position.x=i.x+e*n.x,t.position.y=i.y+e*n.y,t.velocity.mult(o),!0}}else if("inline"===a.type&&t.initialPosition){const i=(0,e.Yf)(t.initialPosition,t.getPosition()),{velocity:n}=t;if(i>this._moveRadius)return n.x=n.y*h-n.x,n.y=n.x*h-n.y,!0}return!1},this._randomPoint=()=>{const t=this._container,i=t.actualOptions.polygon;if(!i)return;let n;if("inline"===i.type)switch(i.inline.arrangement){case"random-point":n=this._getRandomPoint();break;case"random-length":n=this._getRandomPointByLength();break;case"equidistant":n=this._getEquidistantPointByIndex(t.particles.count);break;default:n=this._getPointByIndex(t.particles.count)}else{const i=t.canvas.size;n={x:(0,e.G0)()*i.width,y:(0,e.G0)()*i.height}}return this._checkInsidePolygon(n)?n:this._randomPoint()},this._container=t,this._engine=i,this.dimension={height:0,width:0},this._moveRadius=0,this._scale=1}clickPositionValid(t){const i=this._container.actualOptions.polygon;return!(null===i||void 0===i||!i.enable)&&"none"!==i.type&&"inline"!==i.type&&this._checkInsidePolygon(t)}async draw(t){var i;if(null===(i=this.paths)||void 0===i||!i.length)return;const e=this._container.actualOptions.polygon;if(null===e||void 0===e||!e.enable)return;const o=e.draw;if(!o.enable)return;const a=this.raw;for(const s of this.paths){const i=s.path2d;if(t)if(i&&this.offset){const{drawPolygonMaskPath:e}=await n.e(7299).then(n.bind(n,7299));e(t,i,o.stroke,this.offset)}else if(a){const{drawPolygonMask:i}=await n.e(7299).then(n.bind(n,7299));i(t,a,o.stroke)}}}async init(){const t=this._container,i=t.actualOptions.polygon,n=t.retina.pixelRatio;i&&(this._moveRadius=i.move.radius*n,this._scale=i.scale*n,i.enable&&await this._initRawData())}async particleBounce(t,i,n){return await this._polygonBounce(t,i,n)}particlePosition(t){var i,n;const o=this._container.actualOptions.polygon;if(null!==o&&void 0!==o&&o.enable&&(null!==(i=null===(n=this.raw)||void 0===n?void 0:n.length)&&void 0!==i?i:0)>0)return(0,e.zw)({},t||this._randomPoint())}particlesInitialization(){const t=this._container.actualOptions.polygon;return!(null===t||void 0===t||!t.enable||"inline"!==t.type||"one-per-point"!==t.inline.arrangement&&"per-point"!==t.inline.arrangement)&&(this._drawPoints(),!0)}resize(){const t=this._container,i=t.actualOptions.polygon;if(null===i||void 0===i||!i.enable||"none"===i.type)return;this.redrawTimeout&&clearTimeout(this.redrawTimeout);this.redrawTimeout=window.setTimeout((()=>{(async()=>{await this._initRawData(!0),await t.particles.redraw()})()}),250)}stop(){delete this.raw,delete this.paths}}}}]);
//# sourceMappingURL=6291.0c5c311d.chunk.js.map