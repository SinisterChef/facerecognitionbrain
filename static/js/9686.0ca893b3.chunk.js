"use strict";(self.webpackChunkfacerecognitionbrain=self.webpackChunkfacerecognitionbrain||[]).push([[9686],{9686:(a,e,t)=>{t.d(e,{GradientUpdater:()=>u});var i=t(4409);class n{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1,this.startValue="random"}load(a){a&&(void 0!==a.count&&(this.count=(0,i.DT)(a.count)),void 0!==a.enable&&(this.enable=a.enable),void 0!==a.speed&&(this.speed=(0,i.DT)(a.speed)),void 0!==a.sync&&(this.sync=a.sync),void 0!==a.startValue&&(this.startValue=a.startValue),void 0!==a.decay&&(this.decay=(0,i.DT)(a.decay)),void 0!==a.delay&&(this.delay=(0,i.DT)(a.delay)))}}class o{constructor(){this.value=0,this.animation=new n}load(a){a&&(this.animation.load(a.animation),void 0!==a.value&&(this.value=(0,i.DT)(a.value)))}}class s{constructor(){this.stop=0,this.value=new i.A9}load(a){a&&(void 0!==a.stop&&(this.stop=a.stop),this.value=i.A9.create(this.value,a.value),void 0!==a.opacity&&(this.opacity=new o,(0,i.Et)(a.opacity)?this.opacity.value=a.opacity:this.opacity.load(a.opacity)))}}class c{constructor(){this.count=0,this.enable=!1,this.speed=0,this.decay=0,this.delay=0,this.sync=!1}load(a){a&&(void 0!==a.count&&(this.count=(0,i.DT)(a.count)),void 0!==a.enable&&(this.enable=a.enable),void 0!==a.speed&&(this.speed=(0,i.DT)(a.speed)),void 0!==a.decay&&(this.decay=(0,i.DT)(a.decay)),void 0!==a.delay&&(this.delay=(0,i.DT)(a.delay)),void 0!==a.sync&&(this.sync=a.sync))}}class l{constructor(){this.value=0,this.animation=new c,this.direction="clockwise"}load(a){a&&(this.animation.load(a.animation),void 0!==a.value&&(this.value=(0,i.DT)(a.value)),void 0!==a.direction&&(this.direction=a.direction))}}class d{constructor(){this.angle=new l,this.colors=[],this.type="random"}load(a){a&&(this.angle.load(a.angle),void 0!==a.colors&&(this.colors=a.colors.map((a=>{const e=new s;return e.load(a),e}))),void 0!==a.type&&(this.type=a.type))}}const r=2*Math.PI;class u{getColorStyles(a,e,t,n){const o=a.gradient;if(!o)return{};const s=o.angle.value,c=0,l=0,d="radial"===o.type?e.createRadialGradient(c,l,0,c,l,t):e.createLinearGradient(Math.cos(s)*-t,Math.sin(s)*-t,Math.cos(s)*t,Math.sin(s)*t);for(const{stop:u,value:v,opacity:y}of o.colors){var r;d.addColorStop(u,(0,i.LC)({h:v.h.value,s:v.s.value,l:v.l.value},null!==(r=null===y||void 0===y?void 0:y.value)&&void 0!==r?r:n))}return{fill:d}}async init(a){const e=(0,i.TA)(a.options.gradient);if(!e)return;const{angle:t}=e;a.gradient={angle:{value:(0,i.VG)(t.value),enable:t.animation.enable,velocity:(0,i.VG)(t.animation.speed)/360*a.container.retina.reduceFactor,decay:1-(0,i.VG)(t.animation.decay),delayTime:(0,i.VG)(t.animation.delay)*i.Xu,max:r,min:0,time:0},type:e.type,colors:[]};let n=e.angle.direction;switch("random"===n&&(n=(0,i.G0)()>i.N3?"counter-clockwise":"clockwise"),n){case"counter-clockwise":case"counterClockwise":a.gradient.angle.status="decreasing";break;case"clockwise":a.gradient.angle.status="increasing"}const o=a.options.reduceDuplicates;for(const s of e.colors){const e=(0,i.R5)(s.value,a.id,o);if(!e)continue;const t=(0,i.pz)(e,s.value.animation,a.container.retina.reduceFactor),n={stop:s.stop,value:t,opacity:s.opacity?{enable:s.opacity.animation.enable,max:(0,i.W9)(s.opacity.value),min:(0,i.Sg)(s.opacity.value),status:"increasing",value:(0,i.VG)(s.opacity.value),velocity:(0,i.VG)(s.opacity.animation.speed)/i.a5*a.container.retina.reduceFactor,decay:1-(0,i.VG)(s.opacity.animation.decay),delayTime:(0,i.VG)(s.opacity.animation.delay)*i.Xu,time:0}:void 0},{opacity:c}=n;if(s.opacity&&c){const a=s.opacity.value;c.min=(0,i.Sg)(a),c.max=(0,i.W9)(a);switch(s.opacity.animation.startValue){case"min":c.value=c.min,c.status="increasing";break;case"max":c.value=c.max,c.status="decreasing";break;default:c.value=(0,i.BH)(c),c.status=(0,i.G0)()>=i.N3?"increasing":"decreasing"}}a.gradient.colors.push(n)}await Promise.resolve()}isEnabled(a){var e,t,i;return!a.destroyed&&!a.spawning&&(!(null===(e=a.gradient)||void 0===e||!e.angle.enable)||null!==(t=null===(i=a.gradient)||void 0===i?void 0:i.colors.some((a=>a.value.h.enable||a.value.s.enable||a.value.l.enable)))&&void 0!==t&&t)}loadOptions(a){for(var e=arguments.length,t=new Array(e>1?e-1:0),n=1;n<e;n++)t[n-1]=arguments[n];for(const o of t){if(null===o||void 0===o||!o.gradient)continue;const e=o.gradient;e&&(a.gradient=(0,i.wJ)(e,(a=>{const e=new d;return e.load(a),e})))}}async update(a,e){const{updateGradient:i}=await t.e(7392).then(t.bind(t,7392));i(a,e)}}}}]);
//# sourceMappingURL=9686.0ca893b3.chunk.js.map